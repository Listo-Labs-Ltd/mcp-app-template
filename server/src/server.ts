/**
 * MCP Server - {{PROJECT_NAME}}
 *
 * TODO: This file should be generated by Claude Code using the openai-app-builder skill.
 * See CLAUDE_CONTEXT.md for the tools and widgets to implement.
 */

import { createServer, type IncomingMessage, type ServerResponse } from "node:http";
import fs from "node:fs";
import path from "node:path";
import { URL, fileURLToPath } from "node:url";
import dotenv from "dotenv";
// NOTE: Server and SSEServerTransport are deprecated but still functional.
// Future migration: Use McpServer and StreamableHTTPServerTransport instead.
// See: https://github.com/modelcontextprotocol/sdk for migration guide.
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import {
  CallToolRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ListToolsRequestSchema,
  ReadResourceRequestSchema,
  type CallToolRequest,
  type Tool,
  type Resource,
  type ResourceTemplate,
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";

// Setup paths
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = path.resolve(__dirname, "..");
dotenv.config({ path: path.resolve(ROOT_DIR, "..", ".env") });

const PORT = parseInt(process.env.PORT || "8000", 10);
const ASSETS_DIR = path.resolve(ROOT_DIR, "..", "assets");
const API_BASE_URL = process.env.API_BASE_URL || "http://localhost:3000";
const ASSETS_BASE_URL = process.env.ASSETS_BASE_URL || `http://localhost:${PORT}/assets`;

// Session management
interface Session {
  server: Server;
  transport: SSEServerTransport;
}
const sessions = new Map<string, Session>();

// TODO: Define your tools here
const tools: Tool[] = [
  // Example tool definition - replace with actual tools
  {
    name: "example_tool",
    description: "Example tool - replace with actual implementation",
    inputSchema: {
      type: "object",
      properties: {
        query: {
          type: "string",
          description: "Search query",
        },
      },
      required: ["query"],
    },
  },
];

// Resource templates for widgets
const resourceTemplates: ResourceTemplate[] = [
  {
    uriTemplate: "ui://{widgetName}",
    name: "Widget UI",
    description: "HTML widget for displaying tool results",
    mimeType: "text/html+skybridge",
  },
];

// TODO: Define resources for each widget (required for ListResourcesRequestSchema)
const resources: Resource[] = [
  // Example resource - replace with actual widget resources
  // {
  //   uri: "ui://example",
  //   name: "Example Widget",
  //   description: "Widget for example tool results",
  //   mimeType: "text/html+skybridge",
  // },
];

// Create MCP server with handlers
function createMcpServer(): Server {
  const server = new Server(
    { name: "{{SERVER_NAME}}", version: "1.0.0" },
    { capabilities: { tools: {}, resources: {} } }
  );

  // List tools handler
  server.setRequestHandler(ListToolsRequestSchema, async () => ({ tools }));

  // CRITICAL: List resources handler - required for widget rendering
  server.setRequestHandler(ListResourcesRequestSchema, async () => ({ resources }));

  // List resource templates handler
  server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => ({
    resourceTemplates,
  }));

  // Tool call handler
  server.setRequestHandler(CallToolRequestSchema, async (request: CallToolRequest) => {
    const { name, arguments: args } = request.params;

    // TODO: Implement tool handlers
    switch (name) {
      case "example_tool": {
        const { query } = args as { query: string };

        // TODO: Call your API and return results
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({ message: `You searched for: ${query}` }),
            },
          ],
          _meta: {
            "openai/outputTemplate": "ui://widget/example.html",
            "openai/widgetAccessible": true,
          },
        };
      }

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  });

  // Resource reader for widgets
  server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
    const { uri } = request.params;

    if (uri.startsWith("ui://widget/")) {
      const widgetName = uri.slice(12).replace(".html", "");
      const htmlPath = path.join(ASSETS_DIR, `${widgetName}.html`);

      if (!fs.existsSync(htmlPath)) {
        throw new Error(`Widget not found: ${widgetName}`);
      }

      let html = fs.readFileSync(htmlPath, "utf8");

      // Inject asset base URL
      html = html.replace(
        /(<meta[^>]*name=["']widget-domain["'][^>]*content=["'])([^"']*)(["'][^>]*>)/i,
        `$1${ASSETS_BASE_URL}$3`
      );

      return {
        contents: [{ uri, mimeType: "text/html+skybridge", text: html }],
      };
    }

    throw new Error(`Unknown resource: ${uri}`);
  });

  return server;
}

// HTTP request body reader
async function readJsonBody(req: IncomingMessage, maxBytes = 16_000): Promise<unknown> {
  const chunks: Buffer[] = [];
  let total = 0;

  for await (const chunk of req) {
    const buf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
    total += buf.length;
    if (total > maxBytes) {
      throw new Error("Payload too large");
    }
    chunks.push(buf);
  }

  const raw = Buffer.concat(chunks).toString("utf8");
  if (!raw) return {};
  return JSON.parse(raw);
}

// Static file MIME types
const MIME_TYPES: Record<string, string> = {
  ".html": "text/html",
  ".js": "application/javascript",
  ".css": "text/css",
  ".json": "application/json",
  ".png": "image/png",
  ".jpg": "image/jpeg",
  ".jpeg": "image/jpeg",
  ".webp": "image/webp",
  ".svg": "image/svg+xml",
  ".map": "application/json",
};

// HTTP Server
const httpServer = createServer(async (req: IncomingMessage, res: ServerResponse) => {
  const url = new URL(req.url || "/", `http://localhost:${PORT}`);
  const method = req.method || "GET";

  // CORS headers
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, X-Session-Id");

  if (method === "OPTIONS") {
    res.writeHead(204);
    res.end();
    return;
  }

  // Health check
  if (url.pathname === "/health") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ ok: true }));
    return;
  }

  // MCP SSE endpoint - GET /mcp
  if (url.pathname === "/mcp" && method === "GET") {
    const server = createMcpServer();
    // IMPORTANT: Pass the POST messages endpoint path to SSEServerTransport
    const transport = new SSEServerTransport("/mcp/messages", res);

    // Use transport.sessionId (auto-generated by SDK)
    sessions.set(transport.sessionId, { server, transport });

    // IMPORTANT: Set up onclose BEFORE server.connect()
    // Only clean up session state - Do NOT call server.close() to avoid infinite recursion
    transport.onclose = () => {
      sessions.delete(transport.sessionId);
    };

    // CRITICAL: Do NOT call res.writeHead() before server.connect()!
    // SSEServerTransport.start() sets the SSE headers internally.
    await server.connect(transport);
    return;
  }

  // MCP messages endpoint - POST /mcp/messages
  if (url.pathname === "/mcp/messages" && method === "POST") {
    const sessionId = url.searchParams.get("sessionId");

    if (!sessionId) {
      res.writeHead(400, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Missing sessionId query parameter" }));
      return;
    }

    const session = sessions.get(sessionId);

    if (!session) {
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Session not found" }));
      return;
    }

    // IMPORTANT: Don't pass body - handlePostMessage reads from req directly
    await session.transport.handlePostMessage(req, res);
    return;
  }

  // Legacy SSE endpoint - GET /sse (for backwards compatibility)
  if (url.pathname === "/sse" && method === "GET") {
    const server = createMcpServer();
    const transport = new SSEServerTransport("/messages", res);

    sessions.set(transport.sessionId, { server, transport });

    transport.onclose = () => {
      sessions.delete(transport.sessionId);
    };

    await server.connect(transport);
    return;
  }

  // Legacy messages endpoint - POST /messages (for backwards compatibility)
  if (url.pathname === "/messages" && method === "POST") {
    const sessionId = url.searchParams.get("sessionId");

    if (!sessionId) {
      res.writeHead(400, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Missing sessionId query parameter" }));
      return;
    }

    const session = sessions.get(sessionId);

    if (!session) {
      res.writeHead(404, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Session not found" }));
      return;
    }

    await session.transport.handlePostMessage(req, res);
    return;
  }

  // Serve static assets
  if (url.pathname.startsWith("/assets/")) {
    const filePath = path.join(ASSETS_DIR, url.pathname.slice(8));

    if (fs.existsSync(filePath)) {
      const ext = path.extname(filePath).toLowerCase();
      const contentType = MIME_TYPES[ext] || "application/octet-stream";

      res.writeHead(200, {
        "Content-Type": contentType,
        "Cache-Control": "public, max-age=3600",
      });
      res.end(fs.readFileSync(filePath));
      return;
    }
  }

  // 404
  res.writeHead(404, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ error: "Not found" }));
});

// Start server
httpServer.listen(PORT, () => {
  console.log(`{{SERVER_NAME}} listening on http://localhost:${PORT}`);
  console.log(`  MCP SSE: http://localhost:${PORT}/mcp`);
  console.log(`  MCP Messages: POST http://localhost:${PORT}/mcp/messages?sessionId=...`);
  console.log(`  Health: http://localhost:${PORT}/health`);
  console.log(`  Assets: http://localhost:${PORT}/assets/`);
});
